#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h> // For timing
#include "blake3.h"
#include <stdbool.h> 

#define NUM_NONCES ((uint64_t)1 << 26)
#define NUM_THREADS 16
#define NONCE_SIZE 6
#define TRUNCATED_HASH_SIZE 16
#define SORT_THREADS 16



int NUM_THREADS_HASH;
int NUM_THREADS_SORT;
int NUM_THREADS_WRITE;
char * FILENAME;
int MEMORY_SIZE;

int FILE_SIZE;

// Structure to hold thread-specific data
typedef struct {
    uint8_t local_hashes[NUM_NONCES / NUM_THREADS][TRUNCATED_HASH_SIZE];
} ThreadData;


// Structure to represent a sorted chunk
typedef struct {
    uint8_t* hashes;
    size_t num_hashes;
} SortChunk;


// Compare function for sorting hashes
int compare_hashes(const void* a, const void* b) {
    return memcmp(a, b, TRUNCATED_HASH_SIZE);
}

// Global array to store all generated hashes
uint8_t output_hashes[NUM_NONCES][TRUNCATED_HASH_SIZE];

// This function generates hashes based on the number of NONCES
//Hashes are computed using the BLAKE3 library
void* hashes_generator(void* arg) {
    uint64_t thread_id = (uint64_t)arg;
    //Calulating the hashes to be generated This fcuntion is called by each thread
    uint64_t hashes_per_thread = NUM_NONCES / NUM_THREADS;
    uint64_t start_nonce = thread_id * hashes_per_thread;

    //Decalring blake3 hasher
    blake3_hasher hasher;
    
    //This data structure isu used to store the hashes generated by this thread
    ThreadData* thread_data = (ThreadData*)malloc(sizeof(ThreadData));

    //All the hashes generated are stored in the local hash buffer
    for (uint64_t i = 0; i < hashes_per_thread; i++) {
        uint64_t nonce = start_nonce + i;
        uint8_t nonce_bytes[NONCE_SIZE];
        for (int j = 0; j < NONCE_SIZE; j++) {
            nonce_bytes[j] = (nonce >> (j * 8)) & 0xFF;
        }
        
        uint8_t input_data[NONCE_SIZE + 10]; // 10 bytes of additional data
        memcpy(input_data, nonce_bytes, NONCE_SIZE);
        memcpy(input_data + NONCE_SIZE, "Hello", 5); // Example additional data

        blake3_hasher_init(&hasher);
        blake3_hasher_update(&hasher, input_data, sizeof(input_data));

        //decalring the local hash buffer to 16
        uint8_t local_hash[TRUNCATED_HASH_SIZE];
        blake3_hasher_finalize(&hasher, local_hash, TRUNCATED_HASH_SIZE);

        //After the hash is generted for the each NONCE 
        //hash stored in the thread's local buffer
        memcpy(thread_data->local_hashes[i], local_hash, TRUNCATED_HASH_SIZE);
    }

    return thread_data;
}

// Function executed by each sorting thread
void* sortChunk(void* arg) {
    SortChunk* chunk = (SortChunk*)arg;
    qsort(chunk->hashes, chunk->num_hashes, TRUNCATED_HASH_SIZE, compare_hashes);
    return NULL;
}


//This function merges the sorted chunks passed to it.
void merge_sorted_chunks(uint8_t* merged_hashes, SortChunk* chunks, size_t num_chunks) {
    size_t indices[num_chunks];
    memset(indices, 0, sizeof(indices));
    //each hash is picked here
    for (size_t i = 0; i < NUM_NONCES; ++i) {
        uint8_t* min_hash = NULL;
        size_t min_index = 0;
        //hash is compared with other hashes in the chunks
        for (size_t j = 0; j < num_chunks; ++j) {
            size_t index = indices[j];
            if (index < chunks[j].num_hashes) {
                uint8_t* hash = &chunks[j].hashes[index * TRUNCATED_HASH_SIZE];
                //minimum hash is found to put in the sorted order
                if (min_hash == NULL || memcmp(hash, min_hash, TRUNCATED_HASH_SIZE) < 0) {
                    min_hash = hash;
                    min_index = j;
                }
            }
        }

        if (min_hash != NULL) {
            //finally the smallest hash found above is copied into merged hashes array
            memcpy(&merged_hashes[i * TRUNCATED_HASH_SIZE], min_hash, TRUNCATED_HASH_SIZE);
            indices[min_index]++;
        }
    }
}

int main(int argc, char *argv[]) {
// CHecking for whether the command line arguments passed satisfy the number of arguments
    if (argc != 15) {
        printf("Usage: %s -t <hash_threads> -o <sort_threads> -i <write_threads> -f <filename> -m <memory_size> -s <file_size> -d <debug>\n", argv[0]);
        return 1;
    }
    //Decalring the variables
    int NUM_THREADS_HASH;
    int NUM_THREADS_SORT;
    int NUM_THREADS_WRITE;
    char * FILENAME;
    int MEMORY_SIZE;
    
    
    //char* debug;
    // Parse each command line argument through looping and prining them on the screen
for (int i = 1; i < argc; i += 2) {
    if (strcmp(argv[i], "-t") == 0) {
        NUM_THREADS_HASH = atoi(argv[i + 1]);
        printf("NUM_THREADS_HASH=%d\n", NUM_THREADS_HASH);
    } else if (strcmp(argv[i], "-o") == 0) {
        NUM_THREADS_SORT = atoi(argv[i + 1]);
        printf("NUM_THREADS_SORT=%d\n", NUM_THREADS_SORT);
    } else if (strcmp(argv[i], "-i") == 0) {
        NUM_THREADS_WRITE = atoi(argv[i + 1]);
        printf("NUM_THREADS_WRITE=%d\n", NUM_THREADS_WRITE);
    } else if (strcmp(argv[i], "-f") == 0) {
        FILENAME = argv[i + 1];
        printf("FILENAME=%s\n", FILENAME);
    } else if (strcmp(argv[i], "-m") == 0) {
        MEMORY_SIZE = atoi(argv[i + 1]);
        printf("MEMORY_SIZE=%d\n", MEMORY_SIZE);
    } else if (strcmp(argv[i], "-s") == 0) {
        FILE_SIZE = atoi(argv[i + 1]);
        printf("FILESIZE=%d\n", FILE_SIZE);
    } else if (strcmp(argv[i], "-d") == 0) {
        printf("DEBUG=%s\n", argv[i + 1]);
    } else {
        printf("Invalid argument: %s\n", argv[i]);
        return 1;
    }
}


// Print HASH_SIZE=10B
printf("HASH_SIZE=10B\n");
// Print HASH_SIZE=10B
printf("NONCE=6B\n");


    //decalring the number of hash threads memory
    pthread_t threads[NUM_THREADS];

    clock_t start_total_time = clock(); // Start total timing
    printf("HASH GENERATION.........STARTED\n");
    // Hash generation threadsa re created and  timer is started
    //Paralle hash generation is performed by using NUM_THREADS
    //Each thread calls the hashes_generator function.
    for (uint64_t i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, hashes_generator, (void*)i);
    }

    // Here we join the threads and wait for the threads to complete hash generation
    ThreadData* thread_results[NUM_THREADS];
    for (uint64_t i = 0; i < NUM_THREADS; i++) {
        //all the threads store the hashes in the local hashe buffer and return those buffer to the thread_resutls buffer
        pthread_join(threads[i], (void**)&thread_results[i]);
    }

    //all the locally generated hashes buffer are read and copied into global hash output
    uint64_t hash_index = 0;
    for (uint64_t i = 0; i < NUM_THREADS; i++) {
        ThreadData* thread_data = thread_results[i];
        for (uint64_t j = 0; j < NUM_NONCES / NUM_THREADS; j++) {
            //process of copying to the ouput hash buffer
            memcpy(output_hashes[hash_index++], thread_data->local_hashes[j], TRUNCATED_HASH_SIZE);
        }
        free(thread_data); // Free thread data memory
    }

    clock_t end_total_time = clock(); // End total timing
    //Calulcating the total time taken to generate the hashes
    double TOTAL_TIME = ((double)(end_total_time - start_total_time)) / CLOCKS_PER_SEC;
    
    // Calculate total number of hashes
    size_t total_hashes = sizeof(output_hashes) / sizeof(output_hashes[0]);

    // Print total number of hashes generated
    printf("Total number of hashes generated: %zu\n", total_hashes);

    // Print total time taken to generate hashes
    printf("Total time taken: %.2f seconds\n", TOTAL_TIME);

/*********************************Sorting**************************************/
     //Flatten the output_hashes array buffer into a single-dimensional array [hash1, hash2, hash3, hash4,........................]
     //allocating the size needed for storing the hashes in the single dimensinal array 
    uint8_t *flattened_hashes = malloc(NUM_NONCES * TRUNCATED_HASH_SIZE);
    if (flattened_hashes == NULL) {
        printf("Error: Memory allocation failed.\n");
        return 1;
    }
   //copying all the hashes into the above created array,.
    for (size_t i = 0; i < NUM_NONCES; i++) {
        memcpy(&flattened_hashes[i * TRUNCATED_HASH_SIZE], output_hashes[i], TRUNCATED_HASH_SIZE);
    }

// Record start time for sorting
    clock_t start_sort_time = clock();
    printf("Sorting started\n");
    // Divide the flattened array into chunks for sorting
    SortChunk sort_chunks[SORT_THREADS];
    // Calculating the size of each chunk to be divided
    size_t chunk_size = NUM_NONCES / SORT_THREADS;
    for (int i = 0; i < SORT_THREADS; ++i) {
        //seperating into chunks by storing the hashes in the sort_chunks variable
        sort_chunks[i].hashes = &flattened_hashes[i * chunk_size * TRUNCATED_HASH_SIZE];
        sort_chunks[i].num_hashes = chunk_size;
    }

    // Here multiple threads are spawned to performing the sorting on each chunk
    pthread_t sort_threads[SORT_THREADS];
    for (int i = 0; i < SORT_THREADS; ++i) {
        //each thread is started with calling the sortChunk method
        pthread_create(&sort_threads[i], NULL, sortChunk, &sort_chunks[i]);
    }

    // Wait for all sorting threads to complete
    for (int i = 0; i < SORT_THREADS; ++i) {
        pthread_join(sort_threads[i], NULL);
    }

    // Here memory is dynamically allocated for storing the merged hshes
    uint8_t *merged_hashes = malloc(NUM_NONCES * TRUNCATED_HASH_SIZE);
    if (merged_hashes == NULL) {
        printf("Error: Memory allocation failed.\n");
        return 1;
    }
    //Finally calling the merging method by pasasing the sort_chunk array where chunk contains sorted chunks of hashes  
    merge_sorted_chunks(merged_hashes, sort_chunks, SORT_THREADS);

    // Record end time for sorting
    clock_t end_sort_time = clock();

    // Calculate sorting time
    double sorting_time_taken = ((double)(end_sort_time - start_sort_time)) / CLOCKS_PER_SEC;
    printf("Sorting time taken: %.2f seconds\n", sorting_time_taken);


/*******************************************************************************/
    // Construct the output file name with the number of threads
    char file_name[100];

    //detemining the file name frpm the input filename argument
    //This is where the output is hash data is stored
    sprintf(file_name, "%s", FILENAME);

    // Write the sorted hashes to a file
    //File is crated and opened
    FILE* file = fopen(file_name, "wb");
    if (file == NULL) {
        printf("Error opening file for writing.\n");
        return 1;
    }
    //Finally writig the sorted and merged hashes into the bin file
    fwrite(merged_hashes, TRUNCATED_HASH_SIZE, NUM_NONCES, file);
    printf("Sorted hashes written to file: %s\n", file_name);
    fclose(file);
    free(merged_hashes); // Free the memory allocated for merged hashe buffer
    free(flattened_hashes); // Free the memory allocated for flattened_hashes
    

    return 0;
}
